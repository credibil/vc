//! # Issuance
//!
//! The Issuance endpoints implement the vercre-holder's credential issuance
//! flow.

pub(crate) mod accept;
pub(crate) mod authorize;
pub(crate) mod credentials;
pub(crate) mod deferred;
pub(crate) mod offer;
pub(crate) mod pin;
pub(crate) mod token;

use std::collections::HashMap;
use std::fmt::Debug;

pub use accept::AuthorizationSpec;
use anyhow::bail;
use chrono::DateTime;
use serde::{Deserialize, Serialize};
use uuid::Uuid;
use vercre_core::{pkce, Kind, Quota};
use vercre_issuer::{
    AuthorizationDetail, AuthorizationRequest, CredentialAuthorization, CredentialConfiguration,
    CredentialDefinition, CredentialIssuance, CredentialOffer, CredentialRequest,
    DeferredCredentialRequest, Format, GrantType, MetadataRequest, OAuthServerRequest,
    PreAuthorizedCodeGrant, ProfileClaims, Proof, ProofClaims, RequestObject, SingleProof,
    TokenGrantType, TokenRequest, TokenResponse,
};
use vercre_macros::credential_request;
use vercre_openid::issuer::{Issuer, Server};
use vercre_w3c_vc::model::VerifiableCredential;

use crate::credential::Credential;
use crate::provider::{HolderProvider, Issuer as IssuerProvider};

/// Types of issuance flow.
///
/// There are options within each flow type. This enum is used to simplify
/// validation logic.
#[derive(Clone, Debug, Default, Serialize, Deserialize)]
pub enum FlowType {
    /// Initiated by the issuer, where the holder is pre-authorized.
    #[default]
    IssuerPreAuthorized,

    /// Initiated by the issuer but requires the holder to be authorized.
    IssuerAuthorized,

    /// Initiated by the holder with authorization details
    HolderAuthDetail,

    /// Initiated by the holder with a scope.
    HolderScope,
}

/// Type of credential request that can be made.
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum CredentialRequestType {
    /// Request by credential identifiers. This is the default.
    CredentialIdentifiers(Vec<String>),

    /// Request by format. Used when the issuance flow is scope-based.
    Format(Format),
}

/// `IssuanceState` represents app state across the steps of the issuance flow.
///
/// The data accumulates as the flow progresses, so not all fields can be
/// trusted at all times. The `status` field should be used to determine which
/// step of the flow the issuance is in and therefore which state fields can be
/// used to support the next step.
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
pub struct IssuanceState {
    /// The unique identifier for the issuance flow.
    ///
    /// Generated by this crate but not used internally. Used by wallet
    /// client providers as a key for stashing state.
    pub id: String,

    /// High-level flow type. Used to validate flow steps and can be used by the
    /// wallet client to control flow logic.
    pub flow_type: FlowType,

    /// Client ID of the holder's agent (wallet). Must be a client registered
    /// with the issuer.
    pub client_id: String,

    /// ID of the holder.
    pub subject_id: String,

    /// Current status of the issuance flow.
    pub status: Status,

    /// The `CredentialOffer` received from the issuer.
    ///
    /// Will be `None` if the flow is initiated by the holder.
    pub offer: Option<CredentialOffer>,

    /// Cached issuer metadata.
    pub issuer: Option<Issuer>,

    /// Cached authorization server metadata.
    pub authorization_server: Option<Server>,

    /// The list of credentials and claims the wallet wants to obtain from those
    /// offered.
    ///
    /// Must be set for holder-initiated flows that don't use scope prior to
    /// making an authorization request.
    pub accepted: Option<Vec<AuthorizationDetail>>,

    /// Credential Issuers MAY support requesting authorization to issue a
    /// credential using OAuth 2.0 scope values.
    /// A scope value and its mapping to a credential type is defined by the
    /// Issuer. A description of scope value semantics or machine readable
    /// definitions could be defined in Issuer metadata. For example,
    /// mapping a scope value to an authorization details object.
    pub scope: Option<String>,

    /// The user's pin, as set from the shell.
    pub pin: Option<String>,

    /// PKCE code verifier for the authorization code flow.
    pub code_verifier: Option<String>,

    /// PKCE code challenge for the authorization code flow.
    pub code_challenge: Option<String>,

    /// The `TokenResponse` received from the issuer.
    ///
    /// Will be `None` if the flow is initiated by the holder or if the flow
    /// has not yet reached the token endpoint.
    pub token: Option<TokenResponse>,

    /// Outstanding deferred credential transaction IDs (key) and corresponding
    /// credential configuration IDs (value).
    ///
    /// Will be empty if there are no outstanding deferred credentials.
    pub deferred: HashMap<String, String>,

    /// Identifier to pass back to the issuer to notify of the success or
    /// otherwise of the credential issuance.
    pub notification_id: Option<String>,

    /// The credentials received from the issuer, ready to be saved to storage.
    ///
    /// Will be empty until credentials have been issued.
    pub credentials: Vec<Credential>,
}

/// Helper functions for using issuance state.
impl IssuanceState {
    /// Creates a new issuance flow.
    #[must_use]
    pub fn new(flow_type: FlowType, client_id: &str, subject_id: &str) -> Self {
        Self {
            id: Uuid::new_v4().to_string(),
            flow_type,
            client_id: client_id.to_string(),
            subject_id: subject_id.to_string(),
            status: Status::Inactive,
            ..Default::default()
        }
    }

    /// Add issuer metadata to the issuance flow state.
    ///
    /// # Errors
    /// Will return an error if the flow state is inconsistent with setting
    /// issuer metadata.
    pub fn issuer(&mut self, issuer: Issuer) -> anyhow::Result<()> {
        if self.status != Status::Inactive || self.issuer.is_some() {
            bail!("cannot set issuer metadata on a flow already started");
        }
        self.issuer = Some(issuer);
        self.status = Status::IssuerMetadataSet;
        Ok(())
    }

    /// Add authorization server metadata to the issuance flow state.
    ///
    /// # Errors
    /// Will return an error if the flow state is inconsistent with setting
    /// authorization server metadata.
    pub fn authorization_server(&mut self, authorization_server: Server) -> anyhow::Result<()> {
        if self.status != Status::IssuerMetadataSet {
            bail!("cannot set authorization server metadata on a flow without issuer metadata");
        }
        if self.authorization_server.is_some() {
            bail!("authorization server metadata already set");
        }
        self.authorization_server = Some(authorization_server);
        self.status = Status::AuthServerSet;
        Ok(())
    }

    /// Gets issuer metadata from the provider and sets that information on
    /// the issuance flow state.
    ///
    /// # Errors
    ///
    /// Returns an error if the provider's metadata request fails.
    // TODO: Remove
    pub async fn set_issuer(
        &mut self, provider: &impl HolderProvider, credential_issuer: &str,
    ) -> anyhow::Result<()> {
        let md_request = MetadataRequest {
            credential_issuer: credential_issuer.into(),
            languages: None, // The wallet client should provide any specific languages required.
        };
        let md_response = IssuerProvider::metadata(provider, md_request).await?;
        self.issuer = Some(md_response.credential_issuer);

        // Set the authorization server metadata.
        // TODO: The spec allows the option for the issuer to provide a list of
        // authorization server identifiers, with the default being the
        // issuer's own ID.
        let auth_md_request = OAuthServerRequest {
            credential_issuer: credential_issuer.into(),
            issuer: None,
        };
        let auth_md_response = IssuerProvider::oauth_server(provider, auth_md_request).await?;
        self.authorization_server = Some(auth_md_response.authorization_server);
        Ok(())
    }
}

/// Issuance flow status values.
///
/// Used to verify the state of a flow before executing the logic for an
/// endpoint.
#[derive(Default, Debug, Serialize, Deserialize, PartialEq, Eq, Clone)]
pub enum Status {
    /// No credential offer is being processed.
    #[default]
    Inactive,

    /// Metadata has been retrieved.
    IssuerMetadataSet,

    /// Authorization server metadata has been retrieved.
    AuthServerSet,

    /// A new credential offer has been received (issuer-initiated only).
    Offered,

    /// The offer requires a user pin to progress.
    PendingPin,

    /// The offer has been accepted and is ready to get an access token.
    Accepted,

    /// The token response has been received. The user has selected some or all
    /// of the credential identifiers in the token response to progress.
    TokenReceived,

    /// A credential has been requested.
    Requested,

    /// The credential offer has failed, with an error message.
    Failed(String),
}

/// An issuance flow is used to orchestrate the change in state as the wallet
/// progresses through a credential issuance flow.
pub struct IssuanceFlow<O, P, Ac, T> {
    offer: O,
    pre_authorized: P,
    accepted: Ac,
    token: T,

    id: String,
    client_id: String,
    subject_id: String,
    issuer: Issuer,
    authorization_server: Server,
    deferred: HashMap<String, String>,
    credentials: Vec<Credential>,
}

/// Type guard for `IssuanceFlow` typestate pattern for flows that are initiated
/// with an offer from the issuer.
pub struct WithOffer(CredentialOffer);
/// Type guard for `IssuanceFlow` typestate pattern for flows that are initiated
/// without an offer from the issuer.
pub struct WithoutOffer;

/// Type guard for `IssuanceFlow` typestate pattern for flows that have had an
/// offer fully or partly accepted and a PIN number (if required).
pub struct Accepted(Vec<AuthorizationDetail>, Option<String>);
/// Type guard for `IssuanceFlow` typestate pattern for flows that have not had
/// any any offer or authorization details accepted.
pub struct NotAccepted;

/// Type guard for `IssuanceFlow` typestate pattern for flows that have had been
/// pre-authorized by the issuer.
pub struct PreAuthorized(PreAuthorizedCodeGrant);
/// Type guard for `IssuanceFlow` typestate pattern for flows that have not been
/// pre-authorized by the issuer.
pub struct NotPreAuthorized;

/// Type guard for `IssuanceFlow` typestate pattern for flows that have had an
/// authorization token issued.
pub struct WithToken(TokenResponse);
/// Type guard for `IssuanceFlow` typestate pattern for flows that have not had
/// an authorization token issued.
pub struct WithoutToken;

impl IssuanceFlow<WithOffer, PreAuthorized, NotAccepted, WithoutToken> {
    /// Create a new issuance flow with an offer from the issuer.
    #[must_use]
    pub fn new(
        client_id: &str, subject_id: &str, issuer: Issuer, auth_server: Server,
        offer: CredentialOffer, pre_auth_code_grant: PreAuthorizedCodeGrant,
    ) -> Self {
        Self {
            offer: WithOffer(offer),
            accepted: NotAccepted,
            pre_authorized: PreAuthorized(pre_auth_code_grant),
            token: WithoutToken,

            id: Uuid::new_v4().to_string(),
            client_id: client_id.into(),
            subject_id: subject_id.into(),
            issuer,
            authorization_server: auth_server,
            deferred: HashMap::new(),
            credentials: Vec::new(),
        }
    }
}

impl IssuanceFlow<WithOffer, NotPreAuthorized, NotAccepted, WithoutToken> {
    /// Create a new issuance flow with an offer but no pre-authorization.
    #[must_use]
    pub fn new(
        client_id: &str, subject_id: &str, issuer: Issuer, auth_server: Server,
        offer: CredentialOffer,
    ) -> Self {
        Self {
            offer: WithOffer(offer),
            accepted: NotAccepted,
            pre_authorized: NotPreAuthorized,
            token: WithoutToken,

            id: Uuid::new_v4().to_string(),
            client_id: client_id.into(),
            subject_id: subject_id.into(),
            issuer,
            authorization_server: auth_server,
            deferred: HashMap::new(),
            credentials: Vec::new(),
        }
    }
}

impl<P> IssuanceFlow<WithOffer, P, NotAccepted, WithoutToken> {
    /// Convenience method to get the offer back out that combines with some
    /// issuer metadata to make it easier to present to the holder so they can
    /// choose what credentials and claims to accept.
    #[must_use]
    pub fn offered(&self) -> HashMap<String, CredentialConfiguration> {
        // Explicitly extract the credential configurations from the issuer
        // metadata that match the credentials on offer to make it easier to
        // present to the holder.
        let mut offered = HashMap::<String, CredentialConfiguration>::new();
        let creds_supported = &self.issuer.credential_configurations_supported;
        for cfg_id in &self.offer.0.credential_configuration_ids {
            // find supported credential in metadata and copy to state object.
            let Some(found) = creds_supported.get(cfg_id) else {
                continue;
            };
            offered.insert(cfg_id.clone(), found.clone());
        }
        offered
    }

    /// Accept the offer from the issuer.
    #[must_use]
    pub fn accept(
        self, accepted: &Option<Vec<AuthorizationSpec>>, pin: Option<String>,
    ) -> IssuanceFlow<WithOffer, P, Accepted, WithoutToken> {
        // If the accept parameter is `None`, all contents of the offer are
        // accepted. Otherwise transform the acceptance into authorization
        // detail format and store on the flow.
        let creds_supported = &self.issuer.credential_configurations_supported;
        let mut auth_details = Vec::new();
        for cfg_id in &self.offer.0.credential_configuration_ids {
            let Some(cred_config) = creds_supported.get(cfg_id) else {
                continue;
            };
            if let Some(accepted) = &accepted {
                if !accepted.iter().any(|a| a.credential_configuration_id == *cfg_id) {
                    continue;
                }
            }
            let claims: Option<ProfileClaims> =
                cred_config.format.claims().map(|claims| match &cred_config.format {
                    Format::JwtVcJson(w3c) | Format::LdpVc(w3c) | Format::JwtVcJsonLd(w3c) => {
                        ProfileClaims::W3c(CredentialDefinition {
                            credential_subject: w3c
                                .credential_definition
                                .credential_subject
                                .clone(),
                            ..Default::default()
                        })
                    }
                    Format::IsoMdl(_) | Format::VcSdJwt(_) => ProfileClaims::Claims(claims),
                });
            let detail = AuthorizationDetail {
                credential: CredentialAuthorization::ConfigurationId {
                    credential_configuration_id: cfg_id.clone(),
                    claims,
                },
                ..Default::default()
            };
            auth_details.push(detail);
        }

        IssuanceFlow {
            offer: self.offer,
            accepted: Accepted(auth_details, pin),
            pre_authorized: self.pre_authorized,
            token: WithoutToken,

            id: self.id,
            client_id: self.client_id,
            subject_id: self.subject_id,
            issuer: self.issuer,
            authorization_server: self.authorization_server,
            deferred: self.deferred,
            credentials: self.credentials,
        }
    }
}

impl IssuanceFlow<WithOffer, PreAuthorized, Accepted, WithoutToken> {
    /// Create a token request from the current state.
    #[must_use]
    pub fn token_request(&self) -> TokenRequest {
        TokenRequest {
            credential_issuer: self.issuer.credential_issuer.clone(),
            client_id: Some(self.client_id.clone()),
            grant_type: TokenGrantType::PreAuthorizedCode {
                pre_authorized_code: self.pre_authorized.0.pre_authorized_code.clone(),
                tx_code: self.accepted.1.clone(),
            },
            authorization_details: Some(self.accepted.0.clone()),
            client_assertion: None,
        }
    }
}

impl IssuanceFlow<WithOffer, NotPreAuthorized, Accepted, WithoutToken> {
    /// Construct an authorization request, a PKCE code challenge and PKCE
    /// verifier from the current state and returns the request and verifier.
    ///
    /// # Errors
    /// Will return an error if the offer contains grants other than an
    /// authorization code grant (can have no grants), or if the authorization
    /// server does not support the authorization code grant.
    pub fn authorization_request(
        &self, redirect_uri: Option<&str>,
    ) -> anyhow::Result<(AuthorizationRequest, String)> {
        let Some(grant_types) = &self.authorization_server.oauth.grant_types_supported else {
            bail!("authorization server does not support any grant types");
        };
        if !grant_types.contains(&GrantType::AuthorizationCode) {
            bail!("authorization server does not support authorization code grant");
        }
        let Some(code_challenge_methods) =
            &self.authorization_server.oauth.code_challenge_methods_supported
        else {
            bail!("code challenge methods missing from authorization server metadata");
        };

        let issuer_state = match &self.offer.0.grants {
            Some(grants) => {
                if let Some(auth_code) = &grants.authorization_code {
                    auth_code.issuer_state.clone()
                } else {
                    bail!("offer does not support authorization code grant");
                }
            }
            None => None,
        };

        // PKCE pair
        let verifier = pkce::code_verifier();
        let code_challenge = pkce::code_challenge(&verifier);

        let request = AuthorizationRequest::Object(RequestObject {
            credential_issuer: self.issuer.credential_issuer.clone(),
            response_type: self.authorization_server.oauth.response_types_supported[0].clone(),
            client_id: self.client_id.clone(),
            redirect_uri: redirect_uri.map(ToString::to_string),
            state: Some(self.id.clone()),
            code_challenge,
            code_challenge_method: code_challenge_methods[0].clone(),
            authorization_details: Some(self.accepted.0.clone()),
            scope: None,
            resource: Some(self.issuer.credential_issuer.clone()),
            subject_id: self.subject_id.clone(),
            wallet_issuer: None,
            user_hint: Some(self.id.clone()),
            issuer_state,
        });

        Ok((request, verifier))
    }
}

impl IssuanceFlow<WithoutOffer, NotPreAuthorized, NotAccepted, WithoutToken> {
    /// Create a new wallet-initiated issuance flow.
    /// Create a new issuance flow with an offer from the issuer.
    #[must_use]
    pub fn new(client_id: &str, subject_id: &str, issuer: Issuer, auth_server: Server) -> Self {
        Self {
            offer: WithoutOffer,
            accepted: NotAccepted,
            pre_authorized: NotPreAuthorized,
            token: WithoutToken,

            id: Uuid::new_v4().to_string(),
            client_id: client_id.into(),
            subject_id: subject_id.into(),
            issuer,
            authorization_server: auth_server,
            deferred: HashMap::new(),
            credentials: Vec::new(),
        }
    }

    /// Create an updated state with the credentials and claims to accept for
    /// a wallet-initiated issuance flow.
    #[must_use]
    pub fn accept(
        self, accepted: Vec<AuthorizationDetail>,
    ) -> IssuanceFlow<WithoutOffer, NotPreAuthorized, Accepted, WithoutToken> {
        IssuanceFlow {
            offer: WithoutOffer,
            accepted: Accepted(accepted, None),
            pre_authorized: NotPreAuthorized,
            token: WithoutToken,

            id: self.id,
            client_id: self.client_id,
            subject_id: self.subject_id,
            issuer: self.issuer,
            authorization_server: self.authorization_server,
            deferred: self.deferred,
            credentials: self.credentials,
        }
    }

    /// Create a scope-based authorization request. The request and a PKCE code
    /// verifier are returned.
    ///
    /// # Errors
    /// Will return an error if the authorization server does not support the
    /// authorization code grant.
    pub fn authorization_request(
        &self, scope: &str, redirect_uri: Option<&str>,
    ) -> anyhow::Result<(AuthorizationRequest, String)> {
        // Check issuer's authorization server metadata supports the
        // authorization code grant.
        let Some(grant_types) = &self.authorization_server.oauth.grant_types_supported else {
            bail!("authorization server does not support any grant types");
        };
        if !grant_types.contains(&GrantType::AuthorizationCode) {
            bail!("authorization server does not support authorization code grant");
        }
        let Some(code_challenge_methods) =
            &self.authorization_server.oauth.code_challenge_methods_supported
        else {
            bail!("code challenge methods missing from authorization server metadata");
        };

        // PKCE pair
        let verifier = pkce::code_verifier();
        let code_challenge = pkce::code_challenge(&verifier);

        let request = AuthorizationRequest::Object(RequestObject {
            credential_issuer: self.issuer.credential_issuer.clone(),
            response_type: self.authorization_server.oauth.response_types_supported[0].clone(),
            client_id: self.client_id.clone(),
            redirect_uri: redirect_uri.map(ToString::to_string),
            state: Some(self.id.clone()),
            code_challenge,
            code_challenge_method: code_challenge_methods[0].clone(),
            authorization_details: None,
            scope: Some(scope.into()),
            resource: Some(self.issuer.credential_issuer.clone()),
            subject_id: self.subject_id.clone(),
            wallet_issuer: None,
            user_hint: Some(self.id.clone()),
            issuer_state: None,
        });

        Ok((request, verifier))
    }

    /// Create a scope-based token request from the current state.
    #[must_use]
    pub fn token_request(
        &self, auth_code: &str, verifier: &str, redirect_uri: Option<&str>,
    ) -> TokenRequest {
        TokenRequest {
            credential_issuer: self.issuer.credential_issuer.clone(),
            client_id: Some(self.client_id.clone()),
            grant_type: TokenGrantType::AuthorizationCode {
                code: auth_code.to_string(),
                redirect_uri: redirect_uri.map(ToString::to_string),
                code_verifier: Some(verifier.into()),
            },
            authorization_details: None,
            client_assertion: None,
        }
    }
}

impl IssuanceFlow<WithoutOffer, NotPreAuthorized, Accepted, WithoutToken> {
    /// Create an authorization request from the current state. The request and
    /// a PKCE code verifier are returned.
    ///
    /// # Errors
    /// Will return an error if the authorization server does not support the
    /// authorization code grant.
    pub fn authorization_request(
        &self, redirect_uri: Option<&str>,
    ) -> anyhow::Result<(AuthorizationRequest, String)> {
        // Check issuer's authorization server metadata supports the
        // authorization code grant.
        let Some(grant_types) = &self.authorization_server.oauth.grant_types_supported else {
            bail!("authorization server does not support any grant types");
        };
        if !grant_types.contains(&GrantType::AuthorizationCode) {
            bail!("authorization server does not support authorization code grant");
        }
        let Some(code_challenge_methods) =
            &self.authorization_server.oauth.code_challenge_methods_supported
        else {
            bail!("code challenge methods missing from authorization server metadata");
        };

        // PKCE pair
        let verifier = pkce::code_verifier();
        let code_challenge = pkce::code_challenge(&verifier);

        let request = AuthorizationRequest::Object(RequestObject {
            credential_issuer: self.issuer.credential_issuer.clone(),
            response_type: self.authorization_server.oauth.response_types_supported[0].clone(),
            client_id: self.client_id.clone(),
            redirect_uri: redirect_uri.map(ToString::to_string),
            state: Some(self.id.clone()),
            code_challenge,
            code_challenge_method: code_challenge_methods[0].clone(),
            authorization_details: Some(self.accepted.0.clone()),
            scope: None,
            resource: Some(self.issuer.credential_issuer.clone()),
            subject_id: self.subject_id.clone(),
            wallet_issuer: None,
            user_hint: Some(self.id.clone()),
            issuer_state: None,
        });

        Ok((request, verifier))
    }
}

impl<O> IssuanceFlow<O, NotPreAuthorized, Accepted, WithoutToken> {
    /// Create a token request from the current state.
    #[must_use]
    pub fn token_request(
        &self, auth_code: &str, verifier: &str, redirect_uri: Option<&str>,
    ) -> TokenRequest {
        TokenRequest {
            credential_issuer: self.issuer.credential_issuer.clone(),
            client_id: Some(self.client_id.clone()),
            grant_type: TokenGrantType::AuthorizationCode {
                code: auth_code.to_string(),
                redirect_uri: redirect_uri.map(ToString::to_string),
                code_verifier: Some(verifier.into()),
            },
            authorization_details: Some(self.accepted.0.clone()),
            client_assertion: None,
        }
    }
}

impl<O, P, Ac> IssuanceFlow<O, P, Ac, WithoutToken> {
    /// Add the token response to the flow state.
    #[must_use]
    pub fn token(self, token: TokenResponse) -> IssuanceFlow<O, P, Ac, WithToken> {
        IssuanceFlow {
            offer: self.offer,
            accepted: self.accepted,
            pre_authorized: self.pre_authorized,
            token: WithToken(token),

            id: self.id,
            client_id: self.client_id,
            subject_id: self.subject_id,
            issuer: self.issuer,
            authorization_server: self.authorization_server,
            deferred: self.deferred,
            credentials: self.credentials,
        }
    }
}

impl<O, P> IssuanceFlow<O, P, Accepted, WithToken> {
    /// Create a set of credential requests from the current state for the
    /// given set of credential identifiers (allows the user to select a
    /// subset of accepted credentials) and a proof JWT.
    ///
    /// If any inconsistencies are found between the authorization details may
    /// result in an empty or partial set of credential requests.
    pub fn credential_requests(
        &self, identifiers: &[String], jwt: &str,
    ) -> Vec<(String, CredentialRequest)> {
        let mut requests = Vec::new();
        let Some(authorized) = &self.token.0.authorization_details else {
            return requests;
        };
        for auth in authorized {
            let cfg_id = match &auth.authorization_detail.credential {
                CredentialAuthorization::ConfigurationId {
                    credential_configuration_id,
                    ..
                } => credential_configuration_id,
                CredentialAuthorization::Format(format_identifier) => {
                    match &self.issuer.credential_configuration_id(format_identifier) {
                        Ok(cfg_id) => cfg_id,
                        Err(_) => continue,
                    }
                }
            };
            // Check the issuer supports this credential configuration. This will only fail if the
            // wallet has messed with state outside of the intended mutation methods.
            let Some(_) = &self.issuer.credential_configurations_supported.get(cfg_id) else {
                continue;
            };
            for cred_id in &auth.credential_identifiers {
                // Check the holder wants this credential.
                if !identifiers.to_vec().contains(cred_id) {
                    continue;
                }
                let credential_issuer = self.issuer.credential_issuer.clone();
                let access_token = &self.token.0.access_token.clone();
                let request = credential_request!({
                    "credential_issuer": credential_issuer,
                    "access_token": access_token,
                    "credential_identifier": cred_id.to_string(),
                    "proof": {
                        "proof_type": "jwt",
                        "jwt": jwt.to_string()
                    }
                });
                requests.push((cfg_id.to_string(), request));
            }
        }
        requests
    }
}

impl<O, P> IssuanceFlow<O, P, NotAccepted, WithToken> {
    /// Create a set of credential requests from the current state for the
    /// given format and a proof JWT.
    ///
    /// # Errors
    /// If no credential configuration can be found in the issuer metadata with
    /// the given scope and format an error is returned.
    pub fn credential_request(
        &self, scope: &str, format: &Format, jwt: &str,
    ) -> anyhow::Result<(String, CredentialRequest)> {
        let Some((cfg_id, _config)) = &self
            .issuer
            .credential_configurations_supported
            .iter()
            .find(|(_, cfg)| cfg.scope.as_deref() == Some(scope) && cfg.format == *format)
        else {
            bail!("credential configuration not found for scope and format");
        };
        let request = CredentialRequest {
            credential_issuer: self.issuer.credential_issuer.clone(),
            access_token: self.token.0.access_token.clone(),
            credential: CredentialIssuance::Format(format.clone()),
            proof: Some(Proof::Single {
                proof_type: SingleProof::Jwt { jwt: jwt.into() },
            }),
            ..Default::default()
        };
        Ok(((*cfg_id).to_string(), request))
    }
}

impl<O, P, Ac> IssuanceFlow<O, P, Ac, WithToken> {
    /// Convenience method to construct a proof so we can sign it and use it in
    /// credential requests.
    pub fn proof(&self) -> ProofClaims {
        ProofClaims {
            iss: Some(self.client_id.clone()),
            aud: self.issuer.credential_issuer.clone(),
            iat: chrono::Utc::now().timestamp(),
            nonce: self.token.0.c_nonce.clone(),
        }
    }

    /// Outstanding deferred credential transaction IDs (key) and corresponding
    /// credential configuration IDs (value).
    ///
    /// Will be empty if there are no outstanding deferred credentials.
    pub fn deferred(&self) -> HashMap<String, String> {
        self.deferred.clone()
    }

    /// The credentials received from the issuer, ready to be saved to storage.
    ///
    /// Will be empty until credentials have been issued.
    pub fn credentials(&self) -> Vec<Credential> {
        self.credentials.clone()
    }

    /// Add a credential to the issuance state, converting the W3C format to a
    /// convenient wallet format.
    ///
    /// # Errors
    /// Will return an error if the current state does not contain the metadata
    /// required to combine with the provided VC.
    pub fn add_credential(
        &mut self, vc: &VerifiableCredential, encoded: &Kind<VerifiableCredential>,
        issued_at: &i64, config_id: &str,
    ) -> anyhow::Result<()> {
        let Some(issuance_date) = DateTime::from_timestamp(*issued_at, 0) else {
            bail!("invalid issuance date");
        };

        let issuer_id = self.issuer.credential_issuer.clone();

        // TODO: Locale support.
        let issuer_name = self
            .issuer
            .display
            .as_ref()
            .map_or_else(|| issuer_id.clone(), |display| display.name.clone());

        let Some(config) = &self.issuer.credential_configurations_supported.get(config_id) else {
            bail!("credential configuration not found in issuer metadata");
        };

        // TODO: add support for embedded proof
        let Kind::String(token) = encoded else {
            bail!("credential is not a JWT");
        };

        // Turn a Quota of Strings into a Vec of Strings for the type of credential.
        let mut type_ = Vec::new();
        match &vc.type_ {
            Quota::One(t) => type_.push(t.clone()),
            Quota::Many(vc_types) => type_.extend(vc_types.clone()),
        }

        // Turn a Quota of credential subjects into a Vec of claim sets.
        let mut subject_claims = Vec::new();
        match vc.credential_subject.clone() {
            Quota::One(cs) => subject_claims.push(cs.into()),
            Quota::Many(vc_claims) => {
                for cs in vc_claims {
                    subject_claims.push(cs.into());
                }
            }
        }

        let storable_credential = Credential {
            id: vc.id.clone().unwrap_or_else(|| format!("urn:uuid:{}", uuid::Uuid::new_v4())),
            issuer: issuer_id,
            issuer_name,
            type_,
            format: config.format.to_string(),
            subject_claims,
            claim_definitions: config.format.claims(),
            issued: token.into(),
            issuance_date,
            valid_from: vc.valid_from,
            valid_until: vc.valid_until,
            display: config.display.clone(),
            logo: None,
            background: None,
        };

        self.credentials.push(storable_credential);
        Ok(())
    }

    /// Construct a deferred credential request.
    ///
    /// # Errors
    /// Will return an error if the issuance state is not consistent with
    /// constructing such a request.
    pub fn deferred_request(&self, transaction_id: &str) -> DeferredCredentialRequest {
        DeferredCredentialRequest {
            transaction_id: transaction_id.into(),
            credential_issuer: self.issuer.credential_issuer.clone(),
            access_token: self.token.0.access_token.clone(),
        }
    }

    /// Add a deferred transaction ID to the issuance state.
    pub fn add_deferred(&mut self, tx_id: &String, cfg_id: &String) {
        self.deferred.insert(tx_id.into(), cfg_id.into());
    }

    /// Remove a pending deferred credential transaction from state.
    pub fn remove_deferred(&mut self, transaction_id: &str) {
        self.deferred.remove(transaction_id);
    }
}
